package com.ict.edu;

public class Ex01 {
	
	// [클래스 class]
	//
	// 클래스의 정의: 객체 (object, 오브젝트, 인스턴스, instance) 를 만들기 위한 모든 정보를 가지고 있는 파일 (like 설계도면, 거푸집)
	//
	// 클래스가 가지고 있는 것: 데이터(상태값), 기능, 생성자
	// 		- 데이터(상태값, 속성) = 변수, 상수		 		→ 멤버 필드
	// 		- 기능(동작)									→ 멤버 메소드
	// 		- 생성자: 클래스를 객체로 만들 때 호출됨		→ 생성자
	//				  생성자 = 클래스 이름 = 저장 이름
	//
	// 클래스의 구조: 헤더, 멤버 필드, 생성자, 멤버 메소드
	//
	//
	// 1. 헤더 >>> [접근 제한자] [클래스 종류] class 클래스이름 {멤버 필드, 생성자, 멤버 메소드}
	//
	// 	1) 접근 제한자	: 외부에서 접근할 수 있는 권한의 단계
	//					  클래스, 멤버 필드, 생성자, 멤버 메소드 모두 맨 처음에 사용할 수 있음
	//		- public		: 누구나 다 접근 가능
	//		- protected		: 같은 패키지와 (다른 패키지의) 상속 관계에서는 접근이 가능
	//		- default(생략)	: 같은 패키지에서는 접근이 가능
	//		- private		: 외부에서는 절대 접근 불가. 같은 클래스 내부의 멤버(멤버 필드, 멤버 메소드)끼리만 접근 가능.
	//
	//	2) 클래스 종류	: 현재 클래스의 종류를 표시
	//					  일반적인 클래스는 이 부분을 생략
	//					  특정 클래스에 해당하는 예약어를 사용 (final, abstract 등)
	//
	//	3) class		: 클래스임을 나타내는 예약어
	//
	//	4) 클래스 이름	: 클래스 이름 = 저장 이름 = 생성자
	//					  첫글자는 대문자, 나머지는 소문자로 작성
	//					  두 단어 이상일 때는 단어의 첫글자는 대문자
	//					  특수문자 및 공백문자 사용하지 않으며, 숫자는 중간이나 뒤에 사용
	//
	// 2. 멤버 필드: 상태값, 데이터, 속성, 특징
	//
	//	1) 변수		: 언제든지 변할 수 있는 데이터(를 저장하는 공간)
	//				  보통 소문자로 작성하며, 두 단어 이상일 때만 두번째 단어부터 단어 첫글자를 대문자로 작성
	//
	//	2) 상수		: 한 번 저장되면 변경할 수 없는 데이터(를 저장하는 공간)
	//				  모든 글자를 대문자로 작성하며, 단어와 단어 사이에 _(underscore)를 사용할 수 있음
	//
	// 3. 멤버 메소드	: 동작, 기능, 작동
	//					  해당 메소드를 호출(실행)하면, 해당 메소드 안에 존재하는 내용을 실행
	//					  메소드는 다른 메소드를 호출할 수 있음
	//				   ** 해당 메소드를 호출하여 내용이 끝나면, 메소드를 호출한 곳으로 되돌아감 **
	//
	//		○ 메소드 구성 >>> [접근제한자] [메소드종류] 반환형 메소드이름([인자=매개변수]) {실행 내용}
	//	
	//		- 접근 제한자
	//
	//		- 메소드 종류	: 일반적인 메소드는 이 부분을 생략
	//						  특정 메소드에 해당하는 예약어를 사용 (static 등)
	//
	//		- 반환형		: 해당 메소드를 호출한 곳으로 되돌아 갈 때 결과의 자료형 (String, int 등)
	//					   ** 만약 결과를 가져가지 않는다면, void 라는 예약어를 사용 **
	//
	//  		ex) public static void main(String[] args){}
	//				>> 메소드 이름은 main 이고, 해당 메소드를 호출한 JVM에게 아무것도 가져가지 않음
	//	
	//		- 메소드 이름	: 소문자로 작성, 두 단어 이상일 때만 두번째 단어부터 단어의 첫글자를 대문자로 자것ㅇ
	//
	//		- 인자			: 메소드가 실행될 때 필요한 정보를 외부에서 받아서 사용함
	//					   ** 메소드 이름이 같더라도, 인자의 개수와 자료형이 다르다면 다른 메소드로 판단
	//					   ** 오버로딩: 메소드의 이름은 같지만, 인자가 다르거나 인자의 개수가 다름
	//					   **  			한 클래스 안에서 같은 이름의 메소드가 여러개 존재
	//					   ** 			(단, 인자의 개수와 자료형은 달라야 함)
	//
	//		** getter()		: 호출하는 입장에서 메소드를 이용하여 변수값을 추출할 때
	//		** setter()		: 호출하는 입장에서 메소드를 이용하여 변수값을 변경할 때
	//
	//
	//
	//	4. 멤버 필드와 멤버 메소드에 공통으로 해당되는 사항
	//
	//		1) instance(인스턴스): 객체 생성
	//
	//		- 인스턴스 필드, 인스턴스 메소드: 객체가 생성될 때 같이 생성되는 필드와 메소드
	//		- 일반적인 클래스의 멤버 필드나 멤버 메소드는 모두 인스턴스에 해당
	//		- 호출 방법 >>> 객체참조변수.멤버필드 / 객체참조변수.멤버메소드
	//		- 인스턴스는 heap 메모리에 생성됨
	//
	//		2) static
	//		- 객체 생성과 상관없이 미리 만들어진 멤버 필드와 멤버 메소드
	//		- static은 반드시 메소드나 필드에 static 이라고 표시를 해야 함
	//		- 언제든지 호출하여 사용 가능
	//		- static 메모리에 생성됨
	//		- 호출 방법 >>> 클래스이름.멤버필드 / 클래스이름.멤버메소드
	//		- ex) System.out.println() , main 메소드 등
	//	
	//	5. 생성자: 클래스를 객체로 만들 때 한 번 호출
	//	
	//		1) 목적	: 멤버 필드(변수와 상수)의 초기값을 지정
	//		
	//		2) 형식	: 클래스 이름과 생성자는 같음
	//				  반환형이 없는 메소드와 같음
	//
	//		3) 클래스를 객체로 만드는 방법
	//			ex) Scanner 	sc 		= 	new Scanner(System.in);		  
	//		 	   [클래스] [참조변수]				[생성자]
	//
	//		4) 모든 클래스는 생성자를 가지고 있음
	//		   생성자가 없는 (것처럼 보이는) 클래스는 기본 생성자가 생략되어 있음
	//		   기본 생상자란 인자가 없는 생성자를 말함 >>> ex. 클래스이름() 
	//
	//		5) 멤버 필드와 멤버 메소드를 사용하기 위한 접근법
	//		- 객체참조변수.멤버필드 / 객체참조변수.멤버메소드
	//		- ex) sc.next(), sc.nextInt() 등
	//
	//		6) 생성자도 오버로딩이 가능함. 즉 하나의 클래스 안에 여러개의 생성자가 존재할 수 있음.
	//
	//
	//
	//
	
		
}
